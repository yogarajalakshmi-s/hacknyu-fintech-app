{"version":3,"names":["_PointerType","require","_State","_PointerTracker","_interopRequireDefault","_GestureHandlerOrchestrator","e","__esModule","default","_defineProperty","r","t","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","GestureHandlerOrchestrator","constructor","Set","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","active","awaiting","activationIndex","MAX_VALUE","removeHandlerFromOrchestrator","indexInGestureHandlers","gestureHandlers","indexOf","indexInAwaitingHandlers","awaitingHandlers","splice","awaitingHandlersTags","delete","handlerTag","handlersToRemove","length","isFinished","state","add","filter","has","hasOtherHandlerToWaitFor","hasToWaitFor","otherHandler","shouldHandlerWaitForOther","some","shouldBeCancelledByFinishedHandler","shouldBeCancelled","State","END","tryActivate","cancel","addAwaitingHandler","handlerState","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","shouldBeCancelledBy","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","shouldWait","onHandlerStateChange","newState","oldState","sendIfDisabled","enabled","sendEvent","UNDETERMINED","includes","currentState","shouldResetProgress","push","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","PointerTracker","shareCommonPointers","delegate","view","checkOverlap","isPointerWithinBothBounds","pointer","point","tracker","getLastAbsoluteCoords","isPointerInBounds","cancelMouseAndPenGestures","currentHandler","forEach","pointerType","PointerType","MOUSE","STYLUS","resetTracker","instance","_instance","exports"],"sources":["GestureHandlerOrchestrator.ts"],"sourcesContent":["import { PointerType } from '../../PointerType';\nimport { State } from '../../State';\n\nimport type IGestureHandler from '../handlers/IGestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static _instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: IGestureHandler[] = [];\n  private awaitingHandlers: IGestureHandler[] = [];\n  private awaitingHandlersTags: Set<number> = new Set();\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: IGestureHandler): void {\n    handler.reset();\n    handler.active = false;\n    handler.awaiting = false;\n    handler.activationIndex = Number.MAX_VALUE;\n  }\n\n  public removeHandlerFromOrchestrator(handler: IGestureHandler): void {\n    const indexInGestureHandlers = this.gestureHandlers.indexOf(handler);\n    const indexInAwaitingHandlers = this.awaitingHandlers.indexOf(handler);\n\n    if (indexInGestureHandlers >= 0) {\n      this.gestureHandlers.splice(indexInGestureHandlers, 1);\n    }\n\n    if (indexInAwaitingHandlers >= 0) {\n      this.awaitingHandlers.splice(indexInAwaitingHandlers, 1);\n      this.awaitingHandlersTags.delete(handler.handlerTag);\n    }\n  }\n\n  private cleanupFinishedHandlers(): void {\n    const handlersToRemove = new Set<IGestureHandler>();\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (this.isFinished(handler.state) && !handler.awaiting) {\n        this.cleanHandler(handler);\n        handlersToRemove.add(handler);\n      }\n    }\n\n    this.gestureHandlers = this.gestureHandlers.filter(\n      (handler) => !handlersToRemove.has(handler)\n    );\n  }\n\n  private hasOtherHandlerToWaitFor(handler: IGestureHandler): boolean {\n    const hasToWaitFor = (otherHandler: IGestureHandler) => {\n      return (\n        !this.isFinished(otherHandler.state) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      );\n    };\n\n    return this.gestureHandlers.some(hasToWaitFor);\n  }\n\n  private shouldBeCancelledByFinishedHandler(\n    handler: IGestureHandler\n  ): boolean {\n    const shouldBeCancelled = (otherHandler: IGestureHandler) => {\n      return (\n        this.shouldHandlerWaitForOther(handler, otherHandler) &&\n        otherHandler.state === State.END\n      );\n    };\n\n    return this.gestureHandlers.some(shouldBeCancelled);\n  }\n\n  private tryActivate(handler: IGestureHandler): void {\n    if (this.shouldBeCancelledByFinishedHandler(handler)) {\n      handler.cancel();\n      return;\n    }\n\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n      return;\n    }\n\n    const handlerState = handler.state;\n\n    if (handlerState === State.CANCELLED || handlerState === State.FAILED) {\n      return;\n    }\n\n    if (this.shouldActivate(handler)) {\n      this.makeActive(handler);\n      return;\n    }\n\n    if (handlerState === State.ACTIVE) {\n      handler.fail();\n      return;\n    }\n\n    if (handlerState === State.BEGAN) {\n      handler.cancel();\n    }\n  }\n\n  private shouldActivate(handler: IGestureHandler): boolean {\n    const shouldBeCancelledBy = (otherHandler: IGestureHandler) => {\n      return this.shouldHandlerBeCancelledBy(handler, otherHandler);\n    };\n\n    return !this.gestureHandlers.some(shouldBeCancelledBy);\n  }\n\n  private cleanupAwaitingHandlers(handler: IGestureHandler): void {\n    const shouldWait = (otherHandler: IGestureHandler) => {\n      return (\n        !otherHandler.awaiting &&\n        this.shouldHandlerWaitForOther(otherHandler, handler)\n      );\n    };\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (shouldWait(otherHandler)) {\n        this.cleanHandler(otherHandler);\n        this.awaitingHandlersTags.delete(otherHandler.handlerTag);\n      }\n    }\n\n    this.awaitingHandlers = this.awaitingHandlers.filter((otherHandler) =>\n      this.awaitingHandlersTags.has(otherHandler.handlerTag)\n    );\n  }\n\n  public onHandlerStateChange(\n    handler: IGestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.enabled && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      for (const otherHandler of this.awaitingHandlers) {\n        if (\n          !this.shouldHandlerWaitForOther(otherHandler, handler) ||\n          !this.awaitingHandlersTags.has(otherHandler.handlerTag)\n        ) {\n          continue;\n        }\n\n        if (newState !== State.END) {\n          this.tryActivate(otherHandler);\n          continue;\n        }\n\n        otherHandler.cancel();\n\n        if (otherHandler.state === State.END) {\n          // Handle edge case, where discrete gestures end immediately after activation thus\n          // their state is set to END and when the gesture they are waiting for activates they\n          // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n          // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n          otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n        }\n\n        otherHandler.awaiting = false;\n      }\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.active) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (!this.awaitingHandlers.includes(handler)) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: IGestureHandler): void {\n    const currentState = handler.state;\n\n    handler.active = true;\n    handler.shouldResetProgress = true;\n    handler.activationIndex = this.activationIndex++;\n\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      if (this.shouldHandlerBeCancelledBy(this.gestureHandlers[i], handler)) {\n        this.gestureHandlers[i].cancel();\n      }\n    }\n\n    for (const otherHandler of this.awaitingHandlers) {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler.awaiting = false;\n      }\n    }\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (!handler.awaiting) {\n      return;\n    }\n\n    handler.awaiting = false;\n\n    this.awaitingHandlers = this.awaitingHandlers.filter(\n      (otherHandler) => otherHandler !== handler\n    );\n  }\n\n  private addAwaitingHandler(handler: IGestureHandler): void {\n    if (this.awaitingHandlers.includes(handler)) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n    this.awaitingHandlersTags.add(handler.handlerTag);\n\n    handler.awaiting = true;\n    handler.activationIndex = this.activationIndex++;\n  }\n\n  public recordHandlerIfNotPresent(handler: IGestureHandler): void {\n    if (this.gestureHandlers.includes(handler)) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.active = false;\n    handler.awaiting = false;\n    handler.activationIndex = Number.MAX_SAFE_INTEGER;\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: IGestureHandler,\n    gh2: IGestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (handler.awaiting || handler.state === State.ACTIVE) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.delegate.view !== otherHandler.delegate.view\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: IGestureHandler,\n    otherHandler: IGestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const isPointerWithinBothBounds = (pointer: number) => {\n      const point = handler.tracker.getLastAbsoluteCoords(pointer);\n\n      return (\n        handler.delegate.isPointerInBounds(point) &&\n        otherHandler.delegate.isPointerInBounds(point)\n      );\n    };\n\n    return handler.getTrackedPointersID().some(isPointerWithinBothBounds);\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: IGestureHandler): void {\n    this.gestureHandlers.forEach((handler: IGestureHandler) => {\n      if (\n        handler.pointerType !== PointerType.MOUSE &&\n        handler.pointerType !== PointerType.STYLUS\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.tracker.resetTracker();\n      }\n    });\n  }\n\n  public static get instance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator._instance) {\n      GestureHandlerOrchestrator._instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator._instance;\n  }\n}\n"],"mappings":"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","ignoreList":[]}