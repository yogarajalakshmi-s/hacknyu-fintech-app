{"version":3,"names":["EventManager","constructor","view","_defineProperty","activePointersCounter","onPointerDown","_event","onPointerAdd","onPointerUp","onPointerRemove","onPointerMove","onPointerLeave","onPointerEnter","onPointerCancel","onPointerOutOfBounds","onPointerMoveOver","onPointerMoveOut","onWheel","setOnPointerDown","callback","setOnPointerAdd","setOnPointerUp","setOnPointerRemove","setOnPointerMove","setOnPointerLeave","setOnPointerEnter","setOnPointerCancel","setOnPointerOutOfBounds","setOnPointerMoveOver","setOnPointerMoveOut","setOnWheel","markAsInBounds","pointerId","pointersInBounds","indexOf","push","markAsOutOfBounds","index","splice","resetManager","exports","default"],"sources":["EventManager.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { AdaptedEvent, EventTypes } from '../interfaces';\n\ntype PointerEventCallback = (event: AdaptedEvent) => void;\n\nexport default abstract class EventManager<T> {\n  protected readonly view: T;\n  protected pointersInBounds: number[] = [];\n  protected activePointersCounter: number;\n\n  constructor(view: T) {\n    this.view = view;\n    this.activePointersCounter = 0;\n  }\n\n  public abstract registerListeners(): void;\n  public abstract unregisterListeners(): void;\n\n  protected abstract mapEvent(\n    event: Event,\n    eventType: EventTypes\n  ): AdaptedEvent;\n\n  protected onPointerDown(_event: AdaptedEvent): void {}\n  protected onPointerAdd(_event: AdaptedEvent): void {}\n  protected onPointerUp(_event: AdaptedEvent): void {}\n  protected onPointerRemove(_event: AdaptedEvent): void {}\n  protected onPointerMove(_event: AdaptedEvent): void {}\n  protected onPointerLeave(_event: AdaptedEvent): void {} // Called only when pointer is pressed (or touching)\n  protected onPointerEnter(_event: AdaptedEvent): void {} // Called only when pointer is pressed (or touching)\n  protected onPointerCancel(_event: AdaptedEvent): void {\n    // When pointer cancel is triggered and there are more pointers on the view, only one pointer is cancelled\n    // Because we want all pointers to be cancelled by that event, we are doing it manually by reseting handler and changing activePointersCounter to 0\n    // Events that correspond to removing the pointer (pointerup, touchend) have condition, that they don't perform any action when activePointersCounter\n    // is equal to 0. This prevents counter from going to negative values, when pointers are removed from view after one of them has been cancelled\n  }\n  protected onPointerOutOfBounds(_event: AdaptedEvent): void {}\n  protected onPointerMoveOver(_event: AdaptedEvent): void {}\n  protected onPointerMoveOut(_event: AdaptedEvent): void {}\n  protected onWheel(_event: AdaptedEvent): void {}\n\n  public setOnPointerDown(callback: PointerEventCallback): void {\n    this.onPointerDown = callback;\n  }\n  public setOnPointerAdd(callback: PointerEventCallback): void {\n    this.onPointerAdd = callback;\n  }\n  public setOnPointerUp(callback: PointerEventCallback): void {\n    this.onPointerUp = callback;\n  }\n  public setOnPointerRemove(callback: PointerEventCallback): void {\n    this.onPointerRemove = callback;\n  }\n  public setOnPointerMove(callback: PointerEventCallback): void {\n    this.onPointerMove = callback;\n  }\n  public setOnPointerLeave(callback: PointerEventCallback): void {\n    this.onPointerLeave = callback;\n  }\n  public setOnPointerEnter(callback: PointerEventCallback): void {\n    this.onPointerEnter = callback;\n  }\n  public setOnPointerCancel(callback: PointerEventCallback): void {\n    this.onPointerCancel = callback;\n  }\n  public setOnPointerOutOfBounds(callback: PointerEventCallback): void {\n    this.onPointerOutOfBounds = callback;\n  }\n  public setOnPointerMoveOver(callback: PointerEventCallback): void {\n    this.onPointerMoveOver = callback;\n  }\n  public setOnPointerMoveOut(callback: PointerEventCallback): void {\n    this.onPointerMoveOut = callback;\n  }\n  public setOnWheel(callback: PointerEventCallback): void {\n    this.onWheel = callback;\n  }\n\n  protected markAsInBounds(pointerId: number): void {\n    if (this.pointersInBounds.indexOf(pointerId) >= 0) {\n      return;\n    }\n\n    this.pointersInBounds.push(pointerId);\n  }\n\n  protected markAsOutOfBounds(pointerId: number): void {\n    const index: number = this.pointersInBounds.indexOf(pointerId);\n\n    if (index < 0) {\n      return;\n    }\n\n    this.pointersInBounds.splice(index, 1);\n  }\n\n  public resetManager(): void {\n    // Reseting activePointersCounter is necessary to make gestures such as pinch work properly\n    // There are gestures that end when there is still one active pointer (like pinch/rotation)\n    // When these gestures end, they are reset, but they still receive events from pointer that is active\n    // This causes trouble, since only onPointerDown registers gesture in orchestrator, and while gestures receive\n    // Events from active pointer after they finished, next pointerdown event will be registered as additional pointer, not the first one\n    // This casues trouble like gestures getting stuck in END state, even though they should have gone to UNDETERMINED\n\n    this.activePointersCounter = 0;\n    this.pointersInBounds = [];\n  }\n}\n"],"mappings":"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","ignoreList":[]}