{"version":3,"names":["_handlersRegistry","require","_RNGestureHandlerModule","_interopRequireDefault","_utils","_ghQueueMicrotask","_utils2","e","__esModule","default","updateHandlers","preparedGesture","gestureConfig","newGestures","prepare","i","length","handler","attachedGestures","checkGestureCallbacksForWorklets","handlerTag","handlers","ghQueueMicrotask","isMounted","shouldUpdateSharedValueIfUsed","gestureId","shouldUseReanimated","config","RNGestureHandlerModule","updateGestureHandler","filterConfig","ALLOWED_PROPS","extractGestureRelations","registerHandler","testId","animatedHandlers","newHandlersValue","filter","g","map","value","scheduleFlushOperations"],"sources":["updateHandlers.ts"],"sourcesContent":["import { GestureType, HandlerCallbacks } from '../gesture';\nimport { registerHandler } from '../../handlersRegistry';\nimport RNGestureHandlerModule from '../../../RNGestureHandlerModule';\nimport { filterConfig, scheduleFlushOperations } from '../../utils';\nimport { ComposedGesture } from '../gestureComposition';\nimport { ghQueueMicrotask } from '../../../ghQueueMicrotask';\nimport { AttachedGestureState } from './types';\nimport {\n  extractGestureRelations,\n  checkGestureCallbacksForWorklets,\n  ALLOWED_PROPS,\n} from './utils';\n\nexport function updateHandlers(\n  preparedGesture: AttachedGestureState,\n  gestureConfig: ComposedGesture | GestureType,\n  newGestures: GestureType[]\n) {\n  gestureConfig.prepare();\n\n  for (let i = 0; i < newGestures.length; i++) {\n    const handler = preparedGesture.attachedGestures[i];\n    checkGestureCallbacksForWorklets(handler);\n\n    // Only update handlerTag when it's actually different, it may be the same\n    // if gesture config object is wrapped with useMemo\n    if (newGestures[i].handlerTag !== handler.handlerTag) {\n      newGestures[i].handlerTag = handler.handlerTag;\n      newGestures[i].handlers.handlerTag = handler.handlerTag;\n    }\n  }\n\n  // Use queueMicrotask to extract handlerTags, because when it's ran, all refs should be updated\n  // and handlerTags in BaseGesture references should be updated in the loop above (we need to wait\n  // in case of external relations)\n  ghQueueMicrotask(() => {\n    if (!preparedGesture.isMounted) {\n      return;\n    }\n\n    // If amount of gesture configs changes, we need to update the callbacks in shared value\n    let shouldUpdateSharedValueIfUsed =\n      preparedGesture.attachedGestures.length !== newGestures.length;\n\n    for (let i = 0; i < newGestures.length; i++) {\n      const handler = preparedGesture.attachedGestures[i];\n\n      // If the gestureId is different (gesture isn't wrapped with useMemo or its dependencies changed),\n      // we need to update the shared value, assuming the gesture runs on UI thread or the thread changed\n      if (\n        handler.handlers.gestureId !== newGestures[i].handlers.gestureId &&\n        (newGestures[i].shouldUseReanimated || handler.shouldUseReanimated)\n      ) {\n        shouldUpdateSharedValueIfUsed = true;\n      }\n\n      handler.config = newGestures[i].config;\n      handler.handlers = newGestures[i].handlers;\n\n      RNGestureHandlerModule.updateGestureHandler(\n        handler.handlerTag,\n        filterConfig(\n          handler.config,\n          ALLOWED_PROPS,\n          extractGestureRelations(handler)\n        )\n      );\n\n      registerHandler(handler.handlerTag, handler, handler.config.testId);\n    }\n\n    if (preparedGesture.animatedHandlers && shouldUpdateSharedValueIfUsed) {\n      const newHandlersValue = preparedGesture.attachedGestures\n        .filter((g) => g.shouldUseReanimated) // Ignore gestures that shouldn't run on UI\n        .map((g) => g.handlers) as unknown as HandlerCallbacks<\n        Record<string, unknown>\n      >[];\n\n      preparedGesture.animatedHandlers.value = newHandlersValue;\n    }\n\n    scheduleFlushOperations();\n  });\n}\n"],"mappings":";;;;;;AACA,IAAAA,iBAAA,GAAAC,OAAA;AACA,IAAAC,uBAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AAEA,IAAAI,iBAAA,GAAAJ,OAAA;AAEA,IAAAK,OAAA,GAAAL,OAAA;AAIiB,SAAAE,uBAAAI,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAEV,SAASG,cAAcA,CAC5BC,eAAqC,EACrCC,aAA4C,EAC5CC,WAA0B,EAC1B;EACAD,aAAa,CAACE,OAAO,CAAC,CAAC;EAEvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,WAAW,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC3C,MAAME,OAAO,GAAGN,eAAe,CAACO,gBAAgB,CAACH,CAAC,CAAC;IACnD,IAAAI,wCAAgC,EAACF,OAAO,CAAC;;IAEzC;IACA;IACA,IAAIJ,WAAW,CAACE,CAAC,CAAC,CAACK,UAAU,KAAKH,OAAO,CAACG,UAAU,EAAE;MACpDP,WAAW,CAACE,CAAC,CAAC,CAACK,UAAU,GAAGH,OAAO,CAACG,UAAU;MAC9CP,WAAW,CAACE,CAAC,CAAC,CAACM,QAAQ,CAACD,UAAU,GAAGH,OAAO,CAACG,UAAU;IACzD;EACF;;EAEA;EACA;EACA;EACA,IAAAE,kCAAgB,EAAC,MAAM;IACrB,IAAI,CAACX,eAAe,CAACY,SAAS,EAAE;MAC9B;IACF;;IAEA;IACA,IAAIC,6BAA6B,GAC/Bb,eAAe,CAACO,gBAAgB,CAACF,MAAM,KAAKH,WAAW,CAACG,MAAM;IAEhE,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,WAAW,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;MAC3C,MAAME,OAAO,GAAGN,eAAe,CAACO,gBAAgB,CAACH,CAAC,CAAC;;MAEnD;MACA;MACA,IACEE,OAAO,CAACI,QAAQ,CAACI,SAAS,KAAKZ,WAAW,CAACE,CAAC,CAAC,CAACM,QAAQ,CAACI,SAAS,KAC/DZ,WAAW,CAACE,CAAC,CAAC,CAACW,mBAAmB,IAAIT,OAAO,CAACS,mBAAmB,CAAC,EACnE;QACAF,6BAA6B,GAAG,IAAI;MACtC;MAEAP,OAAO,CAACU,MAAM,GAAGd,WAAW,CAACE,CAAC,CAAC,CAACY,MAAM;MACtCV,OAAO,CAACI,QAAQ,GAAGR,WAAW,CAACE,CAAC,CAAC,CAACM,QAAQ;MAE1CO,+BAAsB,CAACC,oBAAoB,CACzCZ,OAAO,CAACG,UAAU,EAClB,IAAAU,mBAAY,EACVb,OAAO,CAACU,MAAM,EACdI,qBAAa,EACb,IAAAC,+BAAuB,EAACf,OAAO,CACjC,CACF,CAAC;MAED,IAAAgB,iCAAe,EAAChB,OAAO,CAACG,UAAU,EAAEH,OAAO,EAAEA,OAAO,CAACU,MAAM,CAACO,MAAM,CAAC;IACrE;IAEA,IAAIvB,eAAe,CAACwB,gBAAgB,IAAIX,6BAA6B,EAAE;MACrE,MAAMY,gBAAgB,GAAGzB,eAAe,CAACO,gBAAgB,CACtDmB,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACZ,mBAAmB,CAAC,CAAC;MAAA,CACrCa,GAAG,CAAED,CAAC,IAAKA,CAAC,CAACjB,QAAQ,CAErB;MAEHV,eAAe,CAACwB,gBAAgB,CAACK,KAAK,GAAGJ,gBAAgB;IAC3D;IAEA,IAAAK,8BAAuB,EAAC,CAAC;EAC3B,CAAC,CAAC;AACJ","ignoreList":[]}