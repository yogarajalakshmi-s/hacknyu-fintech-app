{"version":3,"names":["_gesture","require","_reanimatedWrapper","_gestureStateManager","_State","_TouchEventType","_utils","getHandler","type","gesture","CALLBACK_TYPE","BEGAN","onBegin","START","onStart","UPDATE","onUpdate","CHANGE","onChange","END","onEnd","FINALIZE","onFinalize","TOUCHES_DOWN","onTouchesDown","TOUCHES_MOVE","onTouchesMove","TOUCHES_UP","onTouchesUp","TOUCHES_CANCELLED","onTouchesCancelled","touchEventTypeToCallbackType","eventType","TouchEventType","UNDEFINED","runWorklet","event","args","handler","isWorklet","console","warn","tagMessage","isStateChangeEvent","oldState","isTouchEvent","useAnimatedGesture","preparedGesture","needsRebuild","Reanimated","sharedHandlersCallbacks","useSharedValue","lastUpdateEvent","stateControllers","callback","currentCallback","value","i","length","handlerTag","State","UNDETERMINED","state","ACTIVE","undefined","FAILED","CANCELLED","GestureStateManager","create","changeEventCalculator","_gesture$changeEventC","call","useEvent","animatedEventHandler","animatedHandlers"],"sources":["useAnimatedGesture.ts"],"sourcesContent":["import { HandlerCallbacks, CALLBACK_TYPE } from '../gesture';\nimport { Reanimated } from '../reanimatedWrapper';\nimport {\n  GestureTouchEvent,\n  GestureUpdateEvent,\n  GestureStateChangeEvent,\n} from '../../gestureHandlerCommon';\nimport {\n  GestureStateManager,\n  GestureStateManagerType,\n} from '../gestureStateManager';\nimport { State } from '../../../State';\nimport { TouchEventType } from '../../../TouchEventType';\nimport { tagMessage } from '../../../utils';\nimport { AttachedGestureState } from './types';\n\nfunction getHandler(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>\n) {\n  'worklet';\n  switch (type) {\n    case CALLBACK_TYPE.BEGAN:\n      return gesture.onBegin;\n    case CALLBACK_TYPE.START:\n      return gesture.onStart;\n    case CALLBACK_TYPE.UPDATE:\n      return gesture.onUpdate;\n    case CALLBACK_TYPE.CHANGE:\n      return gesture.onChange;\n    case CALLBACK_TYPE.END:\n      return gesture.onEnd;\n    case CALLBACK_TYPE.FINALIZE:\n      return gesture.onFinalize;\n    case CALLBACK_TYPE.TOUCHES_DOWN:\n      return gesture.onTouchesDown;\n    case CALLBACK_TYPE.TOUCHES_MOVE:\n      return gesture.onTouchesMove;\n    case CALLBACK_TYPE.TOUCHES_UP:\n      return gesture.onTouchesUp;\n    case CALLBACK_TYPE.TOUCHES_CANCELLED:\n      return gesture.onTouchesCancelled;\n  }\n}\n\nfunction touchEventTypeToCallbackType(\n  eventType: TouchEventType\n): CALLBACK_TYPE {\n  'worklet';\n  switch (eventType) {\n    case TouchEventType.TOUCHES_DOWN:\n      return CALLBACK_TYPE.TOUCHES_DOWN;\n    case TouchEventType.TOUCHES_MOVE:\n      return CALLBACK_TYPE.TOUCHES_MOVE;\n    case TouchEventType.TOUCHES_UP:\n      return CALLBACK_TYPE.TOUCHES_UP;\n    case TouchEventType.TOUCHES_CANCELLED:\n      return CALLBACK_TYPE.TOUCHES_CANCELLED;\n  }\n  return CALLBACK_TYPE.UNDEFINED;\n}\n\nfunction runWorklet(\n  type: CALLBACK_TYPE,\n  gesture: HandlerCallbacks<Record<string, unknown>>,\n  event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent,\n  ...args: unknown[]\n) {\n  'worklet';\n  const handler = getHandler(type, gesture);\n  if (gesture.isWorklet[type]) {\n    // @ts-ignore Logic below makes sure the correct event is send to the\n    // correct handler.\n    handler?.(event, ...args);\n  } else if (handler) {\n    console.warn(tagMessage('Animated gesture callback must be a worklet'));\n  }\n}\n\nfunction isStateChangeEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureStateChangeEvent {\n  'worklet';\n  // @ts-ignore Yes, the oldState prop is missing on GestureTouchEvent, that's the point\n  return event.oldState != null;\n}\n\nfunction isTouchEvent(\n  event: GestureUpdateEvent | GestureStateChangeEvent | GestureTouchEvent\n): event is GestureTouchEvent {\n  'worklet';\n  return event.eventType != null;\n}\n\nexport function useAnimatedGesture(\n  preparedGesture: AttachedGestureState,\n  needsRebuild: boolean\n) {\n  if (!Reanimated) {\n    return;\n  }\n\n  // Hooks are called conditionally, but the condition is whether the\n  // react-native-reanimated is installed, which shouldn't change while running\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const sharedHandlersCallbacks = Reanimated.useSharedValue<\n    HandlerCallbacks<Record<string, unknown>>[] | null\n  >(null);\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const lastUpdateEvent = Reanimated.useSharedValue<\n    (GestureUpdateEvent | undefined)[]\n  >([]);\n\n  // not every gesture needs a state controller, init them lazily\n  const stateControllers: GestureStateManagerType[] = [];\n\n  const callback = (\n    event: GestureStateChangeEvent | GestureUpdateEvent | GestureTouchEvent\n  ) => {\n    'worklet';\n\n    const currentCallback = sharedHandlersCallbacks.value;\n    if (!currentCallback) {\n      return;\n    }\n\n    for (let i = 0; i < currentCallback.length; i++) {\n      const gesture = currentCallback[i];\n\n      if (event.handlerTag !== gesture.handlerTag) {\n        continue;\n      }\n\n      if (isStateChangeEvent(event)) {\n        if (\n          event.oldState === State.UNDETERMINED &&\n          event.state === State.BEGAN\n        ) {\n          runWorklet(CALLBACK_TYPE.BEGAN, gesture, event);\n        } else if (\n          (event.oldState === State.BEGAN ||\n            event.oldState === State.UNDETERMINED) &&\n          event.state === State.ACTIVE\n        ) {\n          runWorklet(CALLBACK_TYPE.START, gesture, event);\n          lastUpdateEvent.value[gesture.handlerTag] = undefined;\n        } else if (\n          event.oldState !== event.state &&\n          event.state === State.END\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, true);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, true);\n        } else if (\n          (event.state === State.FAILED || event.state === State.CANCELLED) &&\n          event.state !== event.oldState\n        ) {\n          if (event.oldState === State.ACTIVE) {\n            runWorklet(CALLBACK_TYPE.END, gesture, event, false);\n          }\n          runWorklet(CALLBACK_TYPE.FINALIZE, gesture, event, false);\n        }\n      } else if (isTouchEvent(event)) {\n        if (!stateControllers[i]) {\n          stateControllers[i] = GestureStateManager.create(event.handlerTag);\n        }\n\n        if (event.eventType !== TouchEventType.UNDETERMINED) {\n          runWorklet(\n            touchEventTypeToCallbackType(event.eventType),\n            gesture,\n            event,\n            stateControllers[i]\n          );\n        }\n      } else {\n        runWorklet(CALLBACK_TYPE.UPDATE, gesture, event);\n\n        if (gesture.onChange && gesture.changeEventCalculator) {\n          runWorklet(\n            CALLBACK_TYPE.CHANGE,\n            gesture,\n            gesture.changeEventCalculator?.(\n              event,\n              lastUpdateEvent.value[gesture.handlerTag]\n            )\n          );\n\n          lastUpdateEvent.value[gesture.handlerTag] = event;\n        }\n      }\n    }\n  };\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  const event = Reanimated.useEvent(\n    callback,\n    ['onGestureHandlerStateChange', 'onGestureHandlerEvent'],\n    needsRebuild\n  );\n\n  preparedGesture.animatedEventHandler = event;\n  preparedGesture.animatedHandlers = sharedHandlersCallbacks;\n}\n"],"mappings":"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","ignoreList":[]}