{"version":3,"names":["PointerType","isPointerInBounds","view","x","y","rect","getBoundingClientRect","left","right","top","bottom","PointerTypeMapping","Map","MOUSE","TOUCH","STYLUS","OTHER","degToRad","degrees","Math","PI","coneToDeviation","cos","calculateViewScale","_RegExp$exec","styles","getComputedStyle","resultScales","scaleX","scaleY","scale","undefined","scales","split","parseFloat","matrixElements","RegExp","exec","transform","matrixElementsArray","tryExtractStylusData","event","pointerType","get","eventAzimuthAngle","azimuthAngle","eventAltitudeAngle","altitudeAngle","tiltX","tiltY","pressure","spherical2tilt","tilt2spherical","tiltXrad","tiltYrad","abs","tanX","tan","tanY","atan2","atan","sqrt","pow","radToDeg","tanAlt","sin","round","RNSVGElements","isRNSVGElement","viewRef","componentClassName","Object","getPrototypeOf","constructor","name","indexOf","hasOwn"],"sources":["utils.ts"],"sourcesContent":["import { PointerType } from '../PointerType';\nimport type {\n  GestureHandlerRef,\n  Point,\n  StylusData,\n  SVGRef,\n} from './interfaces';\n\nexport function isPointerInBounds(view: HTMLElement, { x, y }: Point): boolean {\n  const rect: DOMRect = view.getBoundingClientRect();\n\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n}\n\nexport const PointerTypeMapping = new Map<string, PointerType>([\n  ['mouse', PointerType.MOUSE],\n  ['touch', PointerType.TOUCH],\n  ['pen', PointerType.STYLUS],\n  ['none', PointerType.OTHER],\n]);\n\nexport const degToRad = (degrees: number) => (degrees * Math.PI) / 180;\n\nexport const coneToDeviation = (degrees: number) =>\n  Math.cos(degToRad(degrees / 2));\n\nexport function calculateViewScale(view: HTMLElement) {\n  const styles = getComputedStyle(view);\n\n  const resultScales = {\n    scaleX: 1,\n    scaleY: 1,\n  };\n\n  // Get scales from scale property\n  if (styles.scale !== undefined && styles.scale !== 'none') {\n    const scales = styles.scale.split(' ');\n\n    if (scales[0]) {\n      resultScales.scaleX = parseFloat(scales[0]);\n    }\n\n    resultScales.scaleY = scales[1]\n      ? parseFloat(scales[1])\n      : parseFloat(scales[0]);\n  }\n\n  // Get scales from transform property\n  const matrixElements = new RegExp(/matrix\\((.+)\\)/).exec(\n    styles.transform\n  )?.[1];\n\n  if (matrixElements) {\n    const matrixElementsArray = matrixElements.split(', ');\n\n    resultScales.scaleX *= parseFloat(matrixElementsArray[0]);\n    resultScales.scaleY *= parseFloat(matrixElementsArray[3]);\n  }\n\n  return resultScales;\n}\n\nexport function tryExtractStylusData(\n  event: PointerEvent\n): StylusData | undefined {\n  const pointerType = PointerTypeMapping.get(event.pointerType);\n\n  if (pointerType !== PointerType.STYLUS) {\n    return;\n  }\n\n  // @ts-ignore This property exists (https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#instance_properties)\n  const eventAzimuthAngle: number | undefined = event.azimuthAngle;\n  // @ts-ignore This property exists (https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent#instance_properties)\n  const eventAltitudeAngle: number | undefined = event.altitudeAngle;\n\n  if (event.tiltX === 0 && event.tiltY === 0) {\n    // If we are in this branch, it means that either tilt properties are not supported and we have to calculate them from altitude and azimuth angles,\n    // or stylus is perpendicular to the screen and we can use altitude / azimuth instead of tilt\n\n    // If azimuth and altitude are undefined in this branch, it means that we are either perpendicular to the screen,\n    // or that none of the position sets is supported. In that case, we can treat stylus as perpendicular\n    if (eventAzimuthAngle === undefined || eventAltitudeAngle === undefined) {\n      return {\n        tiltX: 0,\n        tiltY: 0,\n        azimuthAngle: Math.PI / 2,\n        altitudeAngle: Math.PI / 2,\n        pressure: event.pressure,\n      };\n    }\n\n    const { tiltX, tiltY } = spherical2tilt(\n      eventAltitudeAngle,\n      eventAzimuthAngle\n    );\n\n    return {\n      tiltX,\n      tiltY,\n      azimuthAngle: eventAzimuthAngle,\n      altitudeAngle: eventAltitudeAngle,\n      pressure: event.pressure,\n    };\n  }\n\n  const { altitudeAngle, azimuthAngle } = tilt2spherical(\n    event.tiltX,\n    event.tiltY\n  );\n\n  return {\n    tiltX: event.tiltX,\n    tiltY: event.tiltY,\n    azimuthAngle,\n    altitudeAngle,\n    pressure: event.pressure,\n  };\n}\n\n// `altitudeAngle` and `azimuthAngle` are experimental properties, which are not supported on Firefox and Safari.\n// Given that, we use `tilt` properties and algorithm that converts one value to another.\n//\n// Source: https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle\nfunction tilt2spherical(tiltX: number, tiltY: number) {\n  const tiltXrad = (tiltX * Math.PI) / 180;\n  const tiltYrad = (tiltY * Math.PI) / 180;\n\n  // calculate azimuth angle\n  let azimuthAngle = 0;\n\n  if (tiltX === 0) {\n    if (tiltY > 0) {\n      azimuthAngle = Math.PI / 2;\n    } else if (tiltY < 0) {\n      azimuthAngle = (3 * Math.PI) / 2;\n    }\n  } else if (tiltY === 0) {\n    if (tiltX < 0) {\n      azimuthAngle = Math.PI;\n    }\n  } else if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    // not enough information to calculate azimuth\n    azimuthAngle = 0;\n  } else {\n    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90\n    const tanX = Math.tan(tiltXrad);\n    const tanY = Math.tan(tiltYrad);\n\n    azimuthAngle = Math.atan2(tanY, tanX);\n    if (azimuthAngle < 0) {\n      azimuthAngle += 2 * Math.PI;\n    }\n  }\n\n  // calculate altitude angle\n  let altitudeAngle = 0;\n\n  if (Math.abs(tiltX) === 90 || Math.abs(tiltY) === 90) {\n    altitudeAngle = 0;\n  } else if (tiltX === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltYrad);\n  } else if (tiltY === 0) {\n    altitudeAngle = Math.PI / 2 - Math.abs(tiltXrad);\n  } else {\n    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90\n    altitudeAngle = Math.atan(\n      1.0 /\n        Math.sqrt(\n          Math.pow(Math.tan(tiltXrad), 2) + Math.pow(Math.tan(tiltYrad), 2)\n        )\n    );\n  }\n\n  return { altitudeAngle: altitudeAngle, azimuthAngle: azimuthAngle };\n}\n\n// If we are on a platform that doesn't support `tiltX` and `tiltY`, we have to calculate them from `altitude` and `azimuth` angles.\n//\n// Source: https://w3c.github.io/pointerevents/#converting-between-tiltx-tilty-and-altitudeangle-azimuthangle\nfunction spherical2tilt(altitudeAngle: number, azimuthAngle: number) {\n  const radToDeg = 180 / Math.PI;\n\n  let tiltXrad = 0;\n  let tiltYrad = 0;\n\n  if (altitudeAngle === 0) {\n    // the pen is in the X-Y plane\n    if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {\n      // pen is on positive X axis\n      tiltXrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI / 2) {\n      // pen is on positive Y axis\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle === Math.PI) {\n      // pen is on negative X axis\n      tiltXrad = -Math.PI / 2;\n    }\n    if (azimuthAngle === (3 * Math.PI) / 2) {\n      // pen is on negative Y axis\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = Math.PI / 2;\n    }\n    if (azimuthAngle > Math.PI && azimuthAngle < (3 * Math.PI) / 2) {\n      tiltXrad = -Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n    if (azimuthAngle > (3 * Math.PI) / 2 && azimuthAngle < 2 * Math.PI) {\n      tiltXrad = Math.PI / 2;\n      tiltYrad = -Math.PI / 2;\n    }\n  }\n\n  if (altitudeAngle !== 0) {\n    const tanAlt = Math.tan(altitudeAngle);\n\n    tiltXrad = Math.atan(Math.cos(azimuthAngle) / tanAlt);\n    tiltYrad = Math.atan(Math.sin(azimuthAngle) / tanAlt);\n  }\n\n  const tiltX = Math.round(tiltXrad * radToDeg);\n  const tiltY = Math.round(tiltYrad * radToDeg);\n\n  return { tiltX, tiltY };\n}\n\nconst RNSVGElements = [\n  'Circle',\n  'ClipPath',\n  'Ellipse',\n  'ForeignObject',\n  'G',\n  'Image',\n  'Line',\n  'Marker',\n  'Mask',\n  'Path',\n  'Pattern',\n  'Polygon',\n  'Polyline',\n  'Rect',\n  'Svg',\n  'Symbol',\n  'TSpan',\n  'Text',\n  'TextPath',\n  'Use',\n];\n\n// This function helps us determine whether given node is SVGElement or not. In our implementation of\n// findNodeHandle, we can encounter such element in 2 forms - SVG tag or ref to SVG Element. Since Gesture Handler\n// does not depend on SVG, we use our simplified SVGRef type that has `elementRef` field. This is something that is present\n// in actual SVG ref object.\n//\n// In order to make sure that node passed into this function is in fact SVG element, first we check if its constructor name\n// corresponds to one of the possible SVG elements. Then we also check if `elementRef` field exists.\n// By doing both steps we decrease probability of detecting situations where, for example, user makes custom `Circle` and\n// we treat it as SVG.\nexport function isRNSVGElement(viewRef: SVGRef | GestureHandlerRef) {\n  const componentClassName = Object.getPrototypeOf(viewRef).constructor.name;\n\n  return (\n    RNSVGElements.indexOf(componentClassName) >= 0 &&\n    Object.hasOwn(viewRef, 'elementRef')\n  );\n}\n"],"mappings":"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","ignoreList":[]}